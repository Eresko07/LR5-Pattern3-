### Лабораторная работа №5

---

#### **1. Паттерн "Фабричный метод"**
**Задача:**  
Упрощение процесса создания объектов фруктов без явного указания конкретных классов в коде.  

**Решение:**  
- Инкапсуляция логики создания объектов в отдельном классе `FruitFactory`
- Возможность расширения системы новыми типами фруктов без изменения существующего кода  
- Унификация интерфейса создания объектов  

**Пример из проекта:**  
```cpp
Fruit* apple = FruitFactory::CreateFruit(FruitType::Apple);
```  
**Преимущества:**  
- Избегание жесткого кодирования классов  
- Централизованное управление созданием объектов  
- Упрощение добавления новых типов фруктов  

---

#### **2. Паттерн "Итератор"**
**Задача:**  
Единообразный обход различных контейнеров с фруктами без раскрытия их внутренней структуры.  

**Решение:**  
- Абстрактный интерфейс `Iterator` с методами `First()`, `Next()`, `IsDone()`, `Current()`
- Реализация конкретного итератора для контейнера `ContainerIterator`  

**Пример из проекта:**  
```cpp
ContainerIterator<Fruit> it(&fruitBox);
for(it.First(); !it.IsDone(); it.Next()) {
    it.Current()->Eat();
}
```  
**Преимущества:**  
- Единый способ обхода разных коллекций  
- Сокрытие реализации контейнера  
- Возможность параллельного обхода  

---

#### **3. Паттерн "Стратегия"**
**Задача:**  
Гибкое изменение поведения (способа употребления фруктов) во время выполнения программы.  

**Решение:**  
- Интерфейс `EatingStrategy` с методом `Eat()`
- Конкретные стратегии: `QuickEatStrategy` и `SlowEatStrategy`  

**Пример из проекта:**  
```cpp
EatingStrategy* strategy = new QuickEatStrategy();
strategy->Eat(apple); // Быстрое употребление
```  
**Преимущества:**  
- Возможность динамической смены поведения  
- Изоляция алгоритмов в отдельных классах  
- Упрощение тестирования  

---

#### **4. Паттерн "Шаблонный метод"**
**Задача:**  
Стандартизация процесса обработки фруктов с возможностью кастомизации отдельных этапов.  

**Решение:**  
- Базовый класс `FruitProcessor` с шаблонным методом `Process()`
- Виртуальные методы `Prepare()`, `CoreProcess()`, `Finish()`  

**Пример из проекта:**  
```cpp
class AppleProcessor : public FruitProcessor {
protected:
    void Prepare(Fruit* f) override { 
        cout << "Washing apple..." << endl; 
    }
};
```  
**Преимущества:**  
- Переиспользование общего алгоритма  
- Гибкость через переопределение шагов  
- Контроль точек расширения  

---

### Вывод
Каждый паттерн решает конкретную задачу:
- **Фабрика** — делегирует создание объектов  
- **Итератор** — абстрагирует обход коллекций  
- **Стратегия** — инкапсулирует алгоритмы  
- **Шаблонный метод** — структурирует процессы  

Их комбинация позволяет строить гибкие и расширяемые системы, что и продемонстрировано в проекте фруктовой фабрики.
